import processing.pdf.*;

int pagenum = 3; //page number we're on
int serialnum = 10*(pagenum-1); //serial number to start at
int cardcnt; //counter for the individual cards

//set up some arrays to store colors
float[] hues = new float[10]; 
float[] ranges = new float[10];


//set up some fonts
//BPreplay is a Leroy style font

PFont fontf = createFont("BPreplay-Bold", 13);
PFont fontf12 = createFont("BPreplay", 12);
PFont fontf8 = createFont("BPreplay", 8);
PFont fontf10 = createFont("BPreplay", 10);
PFont fontf10ital = createFont("BPreplay-Italic", 10);

//vertical fine tuning for the font position
float textbumpy = 2.15; //pixels

// page size -  US Letter
float pagew = 11;
float pageh = 8.5;

// Size the QR and the empty buffer pixels to trim
int qrpixels = 31;
int qrtrim = 7;

//Business card size
float CardW = 2;
float CardH = 3.5;

// x and y buffer to center the graphic on the card
float xbuffer = .02;
float ybuffer = .01;

//The size of the actual area in each card we'll work in
float cardw = CardW-2*xbuffer;
float cardh = CardH;

//card division 2 X 5 on sheet
int cardsinx = 5;
int cardsiny = 2;

//where the first card starts on the sheet
float sheetx = .50 ; // + 0.05 bump for Epson
float sheety = .75 ;

//parameters for unfilled circle colors

float unfillsat = 40; //saturation
float unfillvar = 20; //random variance
float unfillbright = 90; //brightness?


float cell = i2p(cardw/qrpixels);//size of a cell that holds the circle
float diam = .75;


PImage qr;
//float baseHue = 65;
float baseHue; // generated per card
float rangeHue; // genereated per card
float onHue;
float onBrightness;


// inches to pixels and back
float i2p(float inches){
  return inches*72;
}

float p2i(float pixels){
  return pixels/72;
}


// here we go
void setup(){      
  //the QR code was generated by Google Charts and saved locally
  //you could do this dynamically
  qr = loadImage("qr1px.png"); 
  size(floor(i2p(pagew)), floor(i2p(pageh)),PDF,"qrdsheet" + pagenum + ".pdf");
  textMode(SHAPE);
  //size(floor(i2p(pagew)), floor(i2p(pageh)));
  smooth(); 
  colorMode(HSB,100);
  background(color(100));
  noLoop();  
  hint(ENABLE_NATIVE_FONTS);
}

/*
* DRAW LOOP
*
*/
void draw(){
  
  // FRONT
  cardcnt = 0;
  for (int i=0; i<cardsinx; i++){
    for (int j=0; j<cardsiny; j++){
      drawCard(i2p(i*CardW+sheetx+xbuffer),i2p(j*CardH+sheety+ybuffer));  
    }
  }
  
  // BACK 
  PGraphicsPDF pdf = (PGraphicsPDF) g;  
  pdf.nextPage();  

  cardcnt = 0;
  for (int i=cardsinx-1; i>=0; i--){
    for (int j=0; j<cardsiny; j++){
      serialnum++;
      drawText(i2p(i*CardW+sheetx),i2p(j*CardH+sheety)); 
      
      println("#"+serialnum+", "+hues[cardcnt]+", "+ranges[cardcnt]);
      cardcnt++;
    }
    }
   print("Export complete");

 exit();
}


/*
*
* GUTS
*
*/

void drawText(float startx, float y){
  //Draws the text on the backside of the card
  float x = startx + i2p(CardW/2);
  textFont(fontf12);
  textAlign(CENTER);
  fill(color(0));
  text("Marc Pfister", x, y+30);
  
  textFont(fontf10ital);
  text("code + craft", x, y+42);
  
  textFont(fontf10);
  text("marc.pfister@XXXXX.com", x, y+60);
  text("XXX-XXX-XXXX", x, y+74);
  
  textFont(fontf8);
  String sertxt = str(serialnum);
  for (int i=sertxt.length(); i<3; i++){
    sertxt = "0" + sertxt;
  }
  text("#"+sertxt, x, y+210, 10);
  text("Seed hue: " +round(hues[cardcnt]*100)/100.0, x, y+220);
  text("Hue range: " +round(ranges[cardcnt]*100)/100.0, x, y+230);
  text("Powered by Processing", x, y+240);
    
  
  
}

int t;
int line1posy = 46; //start of first text line in cells
int line2posy = 51; //start of second
// these arrays store where the letters go, and were calculated manually
// pattern is first cell to start text, then cell for text width
// so 3rd cell, 3 cells wide, then 7th cell, two cells wide, then tenth...
int[] line1posx = {3,3,7,2,10,2,13,2}; // cell to start text,cell for text width,etc
int[] line2posx = {3,2,6,2,9,1,11,2,14,2,17,2,20,2};

String line1 = "MARC";
String line2 = "PFISTER";

//this stores the pattern of circles around the letters
//{num of rows, then cells on, cells off, alternating
// so 12 rows of 31 cells on (showing circles)
// then 3 rows of 3 on, 3 off, 1 on, 2 off..
int[][] pattern = {
  {12,31},
  {3,3,3,1,2,1,2,1,2,16},
  {2,31},
  {3,3,2,1,2,1,1,1,2,1,2,1,2,1,2,9},
  {3,31}
};  

void drawCard(float startx,float starty){
  //draws the pattern on the front of the card
  rangeHue = random(20,40); //range of hues on card
  baseHue = random(100); //base hue to use
  hues[cardcnt] = baseHue;
  ranges[cardcnt] = rangeHue;
  cardcnt++;
  //lets loop thhrough the QR code and draw it with circles
  for (int i=qrtrim; i<qr.width-qrtrim; i++){
    for (int j=qrtrim; j<qr.height-qrtrim; j++){
       if (brightness(qr.get(i,j))<50){
         pcircle(i, j, startx, starty, true);
       }else if(brightness(qr.get(i,j))>50){
         pcircle(i, j, startx, starty, false);
     }
    t = j; 
    }    
  } 
  // draw the rest of the circles at the bottom of the card
  // following the pattern to leaves gaps for the text
  boolean drawon;
  int ii;
  int jj = t+1;
  for (int k=0 ; k < pattern.length; k++){ 
    for (int n=0; n< pattern[k][0]; n++){
      ii=0;
      drawon = true;
      for (int m=1; m<pattern[k].length; m++){
        for (int z=0; z<pattern[k][m]; z++){
          if(drawon){pcircle(ii+7, jj , startx, starty, false);}
          ii++;
        }
        drawon = !drawon;
      }
      jj++;
    }
  }  
  noFill();
  textFont(fontf);
  textAlign(CENTER);
  
  //draw the text
    for (int i = 0; i<line1.length(); i=i+1){
      onHue = ((baseHue + random( -rangeHue,0))+100)%100;
      fill(color(onHue,random(75,100),random(50,75)));
      text(line1.substring(i,i+1),startx+(line1posx[i*2]+float(line1posx[i*2+1])/2.0)*cell,starty+(line1posy*cell)-textbumpy);
      
    } 
   
   for (int i = 0; i<line2.length(); i=i+1){
      onHue = ((baseHue + random(-rangeHue,0))+100)%100;
      fill(color(onHue,random(75,100),random(50,75)));
      text(line2.substring(i,i+1),startx+(line2posx[i*2]+float(line2posx[i*2+1])/2.0)*cell,starty+(line2posy*cell)-textbumpy);
    }  
  
 
}



void pcircle(int x,int y, float startx, float starty,boolean cfill){
  // draw a circle graphic with the appropriate fill
  
  onHue = ((baseHue + random(-rangeHue, rangeHue))+100)%100;
  if (cfill){
    strokeWeight(.4);
    onBrightness = random(60,90);
    fill(color(onHue,random(75,100),onBrightness));
    stroke(color(onHue+ random(-10,10),random(75,100),onBrightness-30));
    
  }else{
    strokeWeight(.5);
    stroke(color(onHue,random(unfillsat,unfillsat+unfillvar),random(unfillbright,100)));
    noFill();
  } 
  ellipse(cell*(x+.5-qrtrim)+startx,cell*(y+.5-qrtrim)+starty,cell*diam,cell*diam);

  
}




